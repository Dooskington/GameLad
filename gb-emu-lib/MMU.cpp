#include "pch.hpp"
#include "MMU.hpp"

/*
    General Memory Map
    ==================
    When m_isBooting = 0x00, override with:
    -MMU:
    0x0000-0x00FF   Boot ROM (256 bytes) [DONE]

    When m_isBooting != 0x00:
    -Cartridge:
    0x0000-0x3FFF   16KB ROM Bank 00     (in cartridge, fixed at bank 00)
    0x4000-0x7FFF   16KB ROM Bank 01..NN (in cartridge, switchable bank number)

    -GPU:
    0x8000-0x9FFF   8KB Video RAM (VRAM) (switchable bank 0-1 in CGB Mode)

    -Cartridge:
    0xA000-0xBFFF   8KB External RAM     (in cartridge, switchable bank, if any)

    -MMU:
    0xC000-0xCFFF   4KB Work RAM Bank 0 (WRAM)
    0xD000-0xDFFF   4KB Work RAM Bank 1 (WRAM)  (switchable bank 1-7 in CGB Mode)
    0xE000-0xFDFF   Same as C000-DDFF (ECHO)    (typically not used)

    -GPU:
    0xFE00-0xFE9F   Sprite Attribute Table (OAM)

    -N/A:
    0xFEA0-0xFEFF   Not Usable

    -GamePad/SerialData/Timer/Audio/GPU:
    0xFF00-0xFF7F   I/O Ports

    -MMU:
    0xFF80-0xFFFE   High RAM (HRAM)
    0xFFFF          Interrupt Enable Register
*/

// This is small enough to just embed directly into the source.  This is the boot ROM of the Gameboy
// encoded as a simple array of 256 bytes.
const byte BIOS[] = 
{
    0x31, 0xFE, 0xFF, 0xAF, 0x21, 0xFF, 0x9F, 0x32, 0xCB, 0x7C, 0x20, 0xFB, 0x21, 0x26, 0xFF, 0x0E,
    0x11, 0x3E, 0x80, 0x32, 0xE2, 0x0C, 0x3E, 0xF3, 0xE2, 0x32, 0x3E, 0x77, 0x77, 0x3E, 0xFC, 0xE0,
    0x47, 0x11, 0x04, 0x01, 0x21, 0x10, 0x80, 0x1A, 0xCD, 0x95, 0x00, 0xCD, 0x96, 0x00, 0x13, 0x7B,
    0xFE, 0x34, 0x20, 0xF3, 0x11, 0xD8, 0x00, 0x06, 0x08, 0x1A, 0x13, 0x22, 0x23, 0x05, 0x20, 0xF9,
    0x3E, 0x19, 0xEA, 0x10, 0x99, 0x21, 0x2F, 0x99, 0x0E, 0x0C, 0x3D, 0x28, 0x08, 0x32, 0x0D, 0x20,
    0xF9, 0x2E, 0x0F, 0x18, 0xF3, 0x67, 0x3E, 0x64, 0x57, 0xE0, 0x42, 0x3E, 0x91, 0xE0, 0x40, 0x04,
    0x1E, 0x02, 0x0E, 0x0C, 0xF0, 0x44, 0xFE, 0x90, 0x20, 0xFA, 0x0D, 0x20, 0xF7, 0x1D, 0x20, 0xF2,
    0x0E, 0x13, 0x24, 0x7C, 0x1E, 0x83, 0xFE, 0x62, 0x28, 0x06, 0x1E, 0xC1, 0xFE, 0x64, 0x20, 0x06,
    0x7B, 0xE2, 0x0C, 0x3E, 0x87, 0xF2, 0xF0, 0x42, 0x90, 0xE0, 0x42, 0x15, 0x20, 0xD2, 0x05, 0x20,
    0x4F, 0x16, 0x20, 0x18, 0xCB, 0x4F, 0x06, 0x04, 0xC5, 0xCB, 0x11, 0x17, 0xC1, 0xCB, 0x11, 0x17,
    0x05, 0x20, 0xF5, 0x22, 0x23, 0x22, 0x23, 0xC9, 0xCE, 0xED, 0x66, 0x66, 0xCC, 0x0D, 0x00, 0x0B,
    0x03, 0x73, 0x00, 0x83, 0x00, 0x0C, 0x00, 0x0D, 0x00, 0x08, 0x11, 0x1F, 0x88, 0x89, 0x00, 0x0E,
    0xDC, 0xCC, 0x6E, 0xE6, 0xDD, 0xDD, 0xD9, 0x99, 0xBB, 0xBB, 0x67, 0x63, 0x6E, 0x0E, 0xEC, 0xCC,
    0xDD, 0xDC, 0x99, 0x9F, 0xBB, 0xB9, 0x33, 0x3E, 0x3c, 0x42, 0xB9, 0xA5, 0xB9, 0xA5, 0x42, 0x4C,
    0x21, 0x04, 0x01, 0x11, 0xA8, 0x00, 0x1A, 0x13, 0xBE, 0x20, 0xFE, 0x23, 0x7D, 0xFE, 0x34, 0x20,
    0xF5, 0x06, 0x19, 0x78, 0x86, 0x23, 0x05, 0x20, 0xFB, 0x86, 0x20, 0xFE, 0x3E, 0x01, 0xE0, 0x50
};

MMU::MMU() :
    m_isBooting(0x00)
{
    RegisterMemoryUnit(0x0000, 0xFFFF, nullptr);
}

MMU::~MMU()
{
}

void MMU::RegisterMemoryUnit(const ushort& startRange, const ushort& endRange, IMemoryUnit* pUnit)
{
    for (ushort index = startRange; index <= endRange; index++)
    {
        m_memoryUnits[index] = pUnit;

        // Prevent wrap around
        if (index == 0xFFFF)
            break;
    }
}

byte MMU::ReadByte(const ushort& address)
{
    // If we are booting and reading below 0x00FF, read from the boot rom.
    if ((m_isBooting == 0x00) && (address <= 0x00FF))
    {
        return BIOS[address];
    }

    auto spUnit = std::move(m_memoryUnits[address]);
    if (spUnit == nullptr)
    {
        return ReadByteInternal(address);
    }
    else
    {
        return spUnit->ReadByte(address);
    }
}

ushort MMU::ReadUShort(const ushort& address)
{
    ushort val = ReadByte(address + 1);
    val = val << 8;
    val |= ReadByte(address);
    return val;
}

bool MMU::WriteByte(const ushort& address, const byte val)
{
    if ((m_isBooting == 0x00) && (address <= 0x00FF))
    {
        Logger::LogError("Access Violation! You can't write to the boot rom, you silly goose.");
        return false;
    }

    auto spUnit = std::move(m_memoryUnits[address]);
    if (spUnit == nullptr)
    {
        return WriteByteInternal(address, val);
    }
    else
    {
        return spUnit->WriteByte(address, val);
    }
}

byte MMU::ReadByteInternal(const ushort& address)
{
    /*
    -MMU:
    0xC000-0xCFFF   4KB Work RAM Bank 0 (WRAM)
    0xD000-0xDFFF   4KB Work RAM Bank 1 (WRAM)  (switchable bank 1-7 in CGB Mode)
    0xE000-0xFDFF   Same as C000-DDFF (ECHO)    (typically not used)\
    0xFF50          Boot indicator
    0xFF80-0xFFFE   High RAM (HRAM)
    0xFFFF          Interrupt Enable Register
    */

    if (address >= 0xC000 && address <= 0xCFFF)
    {
        return m_bank0[address - 0xC000];
    }
    else if (address >= 0xC000 && address <= 0xDFFF)
    {
        return m_bank1[address - 0xD000];
    }
    else if (address >= 0xE000 && address <= 0xEFFF)
    {
        return m_bank0[address - 0xE000];
    }
    else if (address >= 0xF000 && address <= 0xFDFF)
    {
        return m_bank1[address - 0xF000];
    }
    else if (address >= 0xFEA0 && address <= 0xFEFF)
    {
        // Unusable memory
        return 0x00;
    }
    else if (address >= 0xFF80 && address <= 0xFFFE)
    {
        return m_HRAM[address - 0xFF80];
    }
    else if (address == 0xFFFF)
    {
        return m_IE;
    }
    else if (address == 0xFF0F)
    {
        return m_IF;
    }
    else if (address == 0xFF50)
    {
        return m_isBooting;
    }
    else if (address == 0xFF4D)
    {
        return m_Key1;
    }
    else
    {
        return 0x00;
    }
}

bool MMU::WriteByteInternal(const ushort& address, const byte val)
{
    if (address >= 0xC000 && address <= 0xCFFF)
    {
        m_bank0[address - 0xC000] = val;
    }
    else if (address >= 0xC000 && address <= 0xDFFF)
    {
        m_bank1[address - 0xD000] = val;
    }
    else if (address >= 0xE000 && address <= 0xEFFF)
    {
        m_bank0[address - 0xE000] = val;
    }
    else if (address >= 0xF000 && address <= 0xFDFF)
    {
        m_bank1[address - 0xF000] = val;
    }
    else if (address >= 0xFEA0 && address <= 0xFEFF)
    {
        // Unusable memory
    }
    else if (address >= 0xFF80 && address <= 0xFFFE)
    {
        m_HRAM[address - 0xFF80] = val;
    }
    else if (address == 0xFFFF)
    {
        m_IE = val;
    }
    else if (address == 0xFF0F)
    {
        m_IF = val;
    }
    else if (address == 0xFF50)
    {
        m_isBooting = val;
    }
    else if (address == 0xFF4D)
    {
        m_Key1 = val;
    }

    return true;
}
